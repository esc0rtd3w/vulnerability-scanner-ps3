from idc import *
from idaapi import *
from idautils import *

'''
Functions listed in order of being most dangerous or potentially unsafe when not used carefully

gets
strcpy
strcat
sprintf
sscanf
fscanf
scanf
realpath
getenv
strncpy
strncat
snprintf
vsprintf
vscanf
fscanf
fgets
fgetws
strtok
wcstok
memcpy
memmove
read
pread
write
pwrite
wcsncpy
wcsncat
swprintf
vfprintf
vfwprintf
vfwscanf
vprintf
vscanf
vsscanf
vswscanf
vwscanf
wscanf
strncpy_s
strncat_s
strcpy_s
strcat_s
wcsncpy_s
wcsncat_s
wcscpy_s
wcscat_s
_tcsncpy_s
_tcscat_s
_tcsncat_s
_tcscpy_s
_mbsncpy_s
_mbscat_s
_mbsncat_s
_mbscpy_s
memmove_s
strtok_s
wcstok_s
getenv_s
fgetc
fgetwc
strpbrk
wcspbrk
bsearch
qsort
asctime
gmtime
localtime
strxfrm
wcsxfrm
strcoll
wcscoll
_tcsxfrm
_tcscoll
lstrcat
lstrcpy
mbscat
mbscpy
mbsncat
olestrcat
snwprintf
swscanf
wcscat
wcscpy
wmemcpy
wsprintf
wvsprintf
_ftcscat
_getws
_mbscat
_mbsncat
_mbscpy
_mbsncpy
_tcsncpy
_tcscpy
_tcsncat
_tcscat
'''
    



################################################################################
#
# dangerous_functions dictionary, with names, types, args, and descriptions
#
################################################################################

dangerous_functions = {
    "fread"         : "size_t fread(void *buffer, size_t size, size_t count, FILE *stream) - buffer must be large enough to contain size*count bytes!",
    "gets"          : "char *gets(char *buffer) - Buffer overflow!!",
    "lstrcat"       : "LPTSTR WINAPI lstrcat(_Inout_ LPTSTR lpString1, _In_ LPTSTR lpString2) - lpString1 must be large enough to contain both strings, including the terminating null character!",
    "lstrcpy"       : "LPTSTR WINAPI lstrcpy(_Out_ LPTSTR lpString1, _In_ LPTSTR lpString2) - lpString1 must be large enough to contain the string pointed to by lpString2, including the terminating null character!",
    "mbscat"        : "mbscat: Refer to _mbscat documentation",
    "mbscpy"        : "mbscpy: Refer to _mbscpy documentation",
    "mbsncat"       : "mbsncat: Refer to _mbsncat documentation",
    "memcpy"        : "void *memcpy(void *dest, const void *src, size_t count) - The dest buffer must be large enough to contain count bytes of the src buffer!",
    "olestrcat": "HRESULT olestrcat(LPOLESTR psz1, LPCOLESTR psz2) - psz1 must be large enough to contain both strings, including the terminating null character!",
    "snprintf": "int snprintf(char *str, size_t size, const char *format, ...) - Ensure that str is large enough to hold the formatted output, including the null-terminator, to avoid potential buffer overflow issues.",
    "snwprintf": "int snwprintf(wchar_t *buffer, size_t count, const wchar_t *format, ...) - If count is smaller than the length of the formatted string (including the null terminator), the buffer will not be null-terminated!",
    "sprintf"       : "int sprintf(char *buffer, const char *format [,argument] ...) - buffer must be large enough to contain the formatted arguments!",
    "sscanf"        : "int sscanf(const char *buffer, const char *format [,argument ] ...) - buffer must be large enough to contain the formatted arguments!",
    "strcpy"        : "char *strcpy(char *strDestination, const char *strSource) - strDestination must be large enough to contain the string pointed to by strSource!",
    "strcat"        : "char *strcat(char *strDestination, const char *strSource) - strDestination must be large enough to contain both strings, including the terminating null character!",
    "strncat"       : "char *strncat(char *strDest, const char *strSource, size_t count) - strDest must be large enough to contain strDest, count bytes of strSource and the terminating null character!",
    "strncpy"       : "char *strncpy(char *destination, const char *source, size_t num) - potential buffer overflow if the source string is longer than the destination buffer and does not contain a null terminator within the first num characters!",
    "swprintf"      : "int swprintf(wchar_t *buffer, const wchar_t *format [,argument] ...) - buffer must be large enough to contain the formatted arguments!",
    "swscanf"       : "int swscanf(const wchar_t *buffer, const wchar_t *format [,argument ] ...) - buffer must be large enough to contain the formatted arguments!",
    "vfprintf"      : "int __cdecl vfprintf(FILE *File, const char *Format, va_list ArgList)",
    "vfwprintf": "int vfwprintf(FILE *stream, const wchar_t *format, va_list argptr) - Insufficient or incorrectly allocated buffer for the output can cause crashes or memory corruption!",
    "vprintf": "int vprintf(const char *format, va_list argptr) - Insufficient or incorrectly allocated buffer for the output can cause crashes or memory corruption!",
    "vwprintf": "int vwprintf(const wchar_t *format, va_list argptr) - Insufficient or incorrectly allocated buffer for the output can cause crashes or memory corruption!",
    "vsprintf"      : "int vsprintf(char *buffer, const char *format, va_list argptr) - format must not be a user-defined string and buffer must be large enough to contain the formatted arguments!",
    "vsnprintf"     : "int vsnprintf(char *buffer, size_t count, const char *format, va_list argptr) - format must not be a user-defined string and buffer must be large enough to contain the formatted arguments!",
    "vsnwprintf": "int vsnwprintf(wchar_t *buffer, size_t count, const wchar_t *format, va_list argptr) - If count is smaller than the length of the formatted string (including the null terminator), the buffer will not be null-terminated!",
    "vswprintf"     : "int vswprintf(wchar_t *buffer, const wchar_t *format, va_list argptr) - format must not be a user-defined string and buffer must be large enough to contain the formatted arguments!",
    "wcscat"        : "wchar_t *wcscat(wchar_t *strDestination, const wchar_t *strSource) - strDestination must be large enough to contain both strings, including the terminating null character!",
    "wcsncat"       : "wchar_t *wcsncat(wchar_t *strDest, const wchar_t *strSource, size_t count) - strDest must be large enough to contain strDest, count*sizeof(wchar_t) bytes of strSource and the terminating null character!",
    "wcscpy"        : "wchar_t *wcscpy(wchar_t *strDestination, const wchar_t *strSource) - strDestination must be large enough to contain the string pointed to by strSource!",
    "wmemcpy"       : "wchar_t *wmemcpy(wchar_t *dest, const wchar_t *src, size_t count) - The dest buffer must be large enough to contain count bytes of the src buffer!", 
    "wsprintf"      : "int wsprintf(_Out_ LPTSTR lpOut, _In_ LPCTSTR lpFmt, _In_ ...) - lpOut must be large enough to contain the formatted arguments!",
    "wvsprintf"     : "int WINAPI wvsprintf(_Out_  LPTSTR lpOutput, _In_   LPCTSTR lpFmt, _In_   va_list arglist) - lpOutput must be large enough to contain the formatted arguments!",
    "_ftcscat": "_TCHAR *_ftcscat(_TCHAR *strDestination, const _TCHAR *strSource) - strDestination must be large enough to contain both strings, including the terminating null character!",
    "_getws"        : "wchar_t *_getws(wchar_t *buffer) - Buffer overflow!!",
    "_mbscat"       : "unsigned char *_mbscat(unsigned char *strDestination, const unsigned char *strSource) - strDestination must be large enough to contain both strings, including the terminating null character!",
    "_mbsncat"      : "unsigned char *_mbsncat(unsigned char *strDest, const unsigned char *strSource, size_t count) - strDest must be large enough to contain strDest, count bytes of strSource and the terminating null character!",
    "_mbscpy"       : "unsigned char *_mbscpy(unsigned char *strDestination, const unsigned char *strSource) - strDestination must be large enough to contain the string pointed to by strSource!",
    "fscanf": "int fscanf(FILE *stream, const char *format, ...) - Make sure the format string and buffer sizes are correct to avoid buffer overflow and undefined behavior!",
    "fwscanf": "int fwscanf(FILE *stream, const wchar_t *format, ...) - Make sure the format string and buffer sizes are correct to avoid buffer overflow and undefined behavior!",
    "getcwd": "char *getcwd(char *buffer, size_t maxlen) - The buffer must be large enough to contain the path string and the terminating null character!",
    "getdcwd": "char *getdcwd(int drive, char *buffer, int maxlen) - The buffer must be large enough to contain the path string and the terminating null character!",
    "getwd": "char *getwd(char *buffer) - The buffer must be large enough to contain the path string and the terminating null character!",
    "printf": "int printf(const char *format [,argument] ...) - The format string must not be a user-defined string and the provided arguments must be large enough to contain the formatted data!",
    "scanf": "int scanf(const char *format [,argument ] ...) - The provided arguments must be large enough to contain the formatted data!",
    "strncpy": "char *strncpy(char *strDest, const char *strSource, size_t count) - strDest must be large enough to contain count bytes of strSource!",
    "vfwscanf": "int vfwscanf(FILE *stream, const wchar_t *format, va_list argptr) - The provided arguments must be large enough to contain the formatted data!",
    "vscanf": "int vscanf(const char *format, va_list argptr) - The provided arguments must be large enough to contain the formatted data!",
    "vsscanf": "int vsscanf(const char *buffer, const char *format, va_list argptr) - The provided arguments must be large enough to contain the formatted data!",
    "vswscanf": "int vswscanf(const wchar_t *buffer, const wchar_t *format, va_list argptr) - The provided arguments must be large enough to contain the formatted data!",
    "vwscanf": "int vwscanf(const wchar_t *format, va_list argptr) - The provided arguments must be large enough to contain the formatted data!",
    "wscanf": "int wscanf(const wchar_t *format [,argument ] ...) - The provided arguments must be large enough to contain the formatted data!",
    "_mbsncpy": "unsigned char *_mbsncpy(unsigned char *strDest, const unsigned char *strSource, size_t count) - strDest must be large enough to contain count bytes of strSource!",
    "_tcsncpy": "_TCHAR *_tcsncpy(_TCHAR *strDest, const _TCHAR *strSource, size_t count) - strDest must be large enough to contain count bytes of strSource!",
    "_tcscpy": "_TCHAR *_tcscpy(_TCHAR *strDestination, const _TCHAR *strSource) - strDestination must be large enough to contain the string pointed to by strSource!",
    "_tcsncat": "_TCHAR *_tcsncat(_TCHAR *strDest, const _TCHAR *strSource, size_t count) - strDest must be large enough to contain strDest, count bytes of strSource and the terminating null character!",
    "_tcscat": "_TCHAR *_tcscat(_TCHAR *strDestination, const _TCHAR *strSource) - strDestination must be large enough to contain both strings, including the terminating null character!",
    "_tcsncpy_s": "_TCHAR *_tcsncpy_s(_TCHAR *strDest, size_t destSize, const _TCHAR *strSource, size_t count) - strDest must be large enough to contain count bytes of strSource or the behavior is undefined!",
    "_tcscat_s": "_TCHAR *_tcscat_s(_TCHAR *strDestination, size_t destSize, const _TCHAR *strSource) - strDestination must be large enough to contain both strings, including the terminating null character, or the behavior is undefined!",
    "_tcsncat_s": "_TCHAR *_tcsncat_s(_TCHAR *strDest, size_t destSize, const _TCHAR *strSource, size_t count) - strDest must be large enough to contain strDest, count bytes of strSource and the terminating null character, or the behavior is undefined!",
    "_tcscpy_s": "_TCHAR *_tcscpy_s(_TCHAR *strDestination, size_t destSize, const _TCHAR *strSource) - strDestination must be large enough to contain the string pointed to by strSource, or the behavior is undefined!",
    "_mbsncpy_s": "unsigned char *_mbsncpy_s(unsigned char *strDest, size_t destSize, const unsigned char *strSource, size_t count) - strDest must be large enough to contain count bytes of strSource, or the behavior is undefined!",
    "_mbscat_s": "unsigned char *_mbscat_s(unsigned char *strDestination, size_t destSize, const unsigned char *strSource) - strDestination must be large enough to contain both strings, including the terminating null character, or the behavior is undefined!",
    "_mbsncat_s": "unsigned char *_mbsncat_s(unsigned char *strDest, size_t destSize, const unsigned char *strSource, size_t count) - strDest must be large enough to contain strDest, count bytes of strSource and the terminating null character, or the behavior is undefined!",
    "_mbscpy_s": "unsigned char *_mbscpy_s(unsigned char *strDestination, size_t destSize, const unsigned char *strSource) - strDestination must be large enough to contain the string pointed to by strSource, or the behavior is undefined!",
    "strncpy_s": "errno_t strncpy_s(char *strDest, size_t destSize, const char *strSource, size_t count) - strDest must be large enough to contain count bytes of strSource, or the behavior is undefined!",
    "strcat_s": "errno_t strcat_s(char *strDestination, size_t destSize, const char *strSource) - strDestination must be large enough to contain both strings, including the terminating null character, or the behavior is undefined!",
    "strncat_s": "errno_t strncat_s(char *strDest, size_t destSize, const char *strSource, size_t count) - strDest must be large enough to contain strDest, count bytes of strSource and the terminating null character, or the behavior is undefined!",
    "strcpy_s": "errno_t strcpy_s(char *strDestination, size_t destSize, const char *strSource) - strDestination must be large enough to contain the string pointed to by strSource, or the behavior is undefined!",
    "wcscpy_s": "errno_t wcscpy_s(wchar_t *strDestination, size_t destSize, const wchar_t *strSource) - strDestination must be large enough to contain the string pointed to by strSource, or the behavior is undefined!",
    "wcscat_s": "errno_t wcscat_s(wchar_t *strDestination, size_t destSize, const wchar_t *strSource) - strDestination must be large enough to contain both strings, including the terminating null character, or the behavior is undefined!",
    "wcsncpy_s": "errno_t wcsncpy_s(wchar_t *strDest, size_t destSize, const wchar_t *strSource, size_t count) - strDest must be large enough to contain count bytes of strSource, or the behavior is undefined!",
    "wcsncat_s": "errno_t wcsncat_s(wchar_t *strDest, size_t destSize, const wchar_t *strSource, size_t count) - strDest must be large enough to contain strDest, count*sizeof(wchar_t) bytes of strSource and the terminating null character, or the behavior is undefined!",
    "memmove_s": "errno_t memmove_s(void *dest, size_t destSize, const void *src, size_t count) - dest and src must not overlap in memory and destSize must be greater than or equal to count, or the behavior is undefined!",
    "strtok_s": "char *strtok_s(char *strToken, const char *strDelimit, char **context) - strToken and context must not be NULL and strDelimit must not contain an empty string!",
    "wcstok_s": "wchar_t *wcstok_s(wchar_t *strToken, const wchar_t *strDelimit, wchar_t **context) - strToken and context must not be NULL and strDelimit must not contain an empty string!",
    "getenv_s": "errno_t getenv_s(size_t *pReturnValue, char *buffer, size_t sizeInChars, const char *varname) - varname must not be an empty string, and if buffer is not NULL, sizeInChars must be greater than 0!",
    "wcsncpy": "wchar_t *wcsncpy(wchar_t *strDest, const wchar_t *strSource, size_t count) - strDest must be large enough to contain count characters from strSource, but no null character is automatically appended!",
    "strtok": "char *strtok(char *str, const char *delim) - The function modifies the input string and is not thread-safe!",
    "strfry": "char *strfry(char *string) - The function shuffles the contents of the input string in place and may cause unexpected behavior if the string is not null-terminated!",
    "realpath": "char *realpath(const char *restrict file_name, char *restrict resolved_name) - If resolved_name is NULL, the behavior is implementation-defined!",
    "fgetc": "int fgetc(FILE *stream) - Be cautious of potential buffer overflow if not used carefully while reading a file!",
    "fgetwc": "wint_t fgetwc(FILE *stream) - Be cautious of potential buffer overflow if not used carefully while reading a file!",
    "strpbrk": "char *strpbrk(const char *str1, const char *str2) - Ensure str1 and str2 are null-terminated to avoid buffer overflow and undefined behavior!",
    "wcspbrk": "wchar_t *wcspbrk(const wchar_t *wcs1, const wchar_t *wcs2) - Ensure wcs1 and wcs2 are null-terminated to avoid buffer overflow and undefined behavior!",
    "bsearch": "void *bsearch(const void *key, const void *base, size_t num, size_t size, int (*compare)(const void *, const void *)) - Be careful with the compare function, as incorrect implementation can lead to unexpected behavior!",
    "qsort": "void qsort(void *base, size_t num, size_t size, int (*compare)(const void *, const void *)) - Be careful with the compare function, as incorrect implementation can lead to unexpected behavior!",
    "asctime": "char *asctime(const struct tm *timeptr) - The function returns a pointer to a static buffer, making it non-thread-safe and prone to data races!",
    "gmtime": "struct tm *gmtime(const time_t *timer) - The function returns a pointer to a static buffer, making it non-thread-safe and prone to data races!",
    "localtime": "struct tm *localtime(const time_t *timer) - The function returns a pointer to a static buffer, making it non-thread-safe and prone to data races!",
    "fgets": "char *fgets(char *str, int count, FILE *stream) - str must be large enough to contain count-1 characters and the terminating null character! Make sure that the buffer size is appropriate for the expected input.",
    "fgetws": "wchar_t *fgetws(wchar_t *str, int count, FILE *stream) - str must be large enough to contain count-1 wide characters and the terminating null character! Make sure that the buffer size is appropriate for the expected input.",
    "getenv": "char *getenv(const char *name) - Ensure that the name parameter is not an empty string! Make sure that the returned string is used carefully to avoid potential buffer overflow issues.",
    "strtok": "char *strtok(char *str, const char *delim) - str and delim must not be NULL and delim must not contain an empty string! Ensure that the input string and delimiter are used carefully to avoid potential buffer overflow issues.",
    "wcstok": "wchar_t *wcstok(wchar_t *str, const wchar_t *delim) - str and delim must not be NULL and delim must not contain an empty string! Ensure that the input wide string and delimiter are used carefully to avoid potential buffer overflow issues.",
    "strxfrm": "size_t strxfrm(char *dest, const char *src, size_t count) - dest must be large enough to contain the transformed src string! Ensure that the buffer size is appropriate for the expected input.",
    "wcsxfrm": "size_t wcsxfrm(wchar_t *dest, const wchar_t *src, size_t count) - dest must be large enough to contain the transformed src wide string! Ensure that the buffer size is appropriate for the expected input.",
    "strcoll": "int strcoll(const char *str1, const char *str2) - Ensure that str1 and str2 are properly null-terminated and used carefully to avoid potential buffer overflow issues.",
    "wcscoll": "int wcscoll(const wchar_t *str1, const wchar_t *str2) - Ensure that str1 and str2 are properly null-terminated and used carefully to avoid potential buffer overflow issues.",
    "_tcsxfrm": "_TCHAR *_tcsxfrm(_TCHAR *dest, const _TCHAR *src, size_t count) - dest must be large enough to contain the transformed src string! Ensure that the buffer size is appropriate for the expected input.",
    "_tcscoll": "int _tcscoll(const _TCHAR *str1, const _TCHAR *str2) - Ensure that str1 and str2 are properly null-terminated and used carefully to avoid potential buffer overflow issues.",
    "read": "ssize_t read(int fd, void *buf, size_t count) - buf must be large enough to contain count bytes of data! Ensure that the buffer size is appropriate for the expected input.",
    "pread": "ssize_t pread(int fd, void *buf, size_t count, off_t offset) - buf must be large enough to contain count bytes of data! Ensure that the buffer size is appropriate for the expected input.",
    "write": "ssize_t write(int fd, const void *buf, size_t count) - Ensure that buf has at least count bytes of data available to avoid potential buffer overflow issues.",
    "pwrite": "ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset) - Ensure that buf has at least count bytes of data available to avoid potential buffer overflow issues.",
}
    



################################################################################
#
# get_interesting_stack_vars function
#
################################################################################
def get_interesting_stack_vars(func_addr):
    
    i = 0
    prev_i = -1
    prev_var_name = ""
    interesting_vars = dict()

    stack_frame = GetFrame(func_addr)
    stack_frame_size = GetStrucSize(stack_frame)

    print "+ Stack frame size: %d bytes" % stack_frame_size    

    # Scan the stack frame for interesting variables
    while i < stack_frame_size:
        var_name = GetMemberName(stack_frame, i)

        if var_name != None:
            if prev_var_name == var_name:
                i = i + 1
            else:
                if prev_var_name == "":
                    prev_i = i
                    prev_var_name = var_name
                    i = i + 1
                else: 
                    prev_var_size = i - prev_i
                    if prev_var_size >= 12:
                        interesting_vars[prev_var_name] = prev_var_size

                    prev_i = i
                    prev_var_name = var_name
                    i = i + 1           
        else:
            i = i + 1

    return interesting_vars




################################################################################
#
# get_interesting_function_calls function
#
################################################################################
def get_interesting_function_calls(func_addr):

    function_calls = dict()
    interesting_calls = dict()

    # Get all the functions called by func
    for i in FuncItems(func_addr):
        if is_call_insn(i):
            xrefs = XrefsFrom(i, XREF_FAR)
            for xref in xrefs:
                function_calls[i] = xref.to


    # Keep the ones that are interesting
    for addr, xref_to in function_calls.iteritems():
        for dangerous_func in dangerous_functions.keys():
            if xref_to == LocByName(dangerous_func):              
                interesting_calls[addr] = dangerous_func

    return interesting_calls




################################################################################
#
# analyze_function function
#
################################################################################
def analyze_function():

    func_name = AskStr("", "Enter function name:")
    func_addr = LocByName(func_name)
    if not func_addr in Functions():
        print "Function '%s' not found." % func_name
        return

        
    print "Analyzing '%s' (0x%08x)..." % (func_name, func_addr)

    # Print a list of interesting variables
    interesting_vars = get_interesting_stack_vars(func_addr)
    if len(interesting_vars) > 0:
        print "  + %d insteresting stack variables have been found." % len(interesting_vars)
        for var_name, var_size in interesting_vars.iteritems():
            print "    - Stack variable: %s\t(%d bytes)" % (var_name, var_size)
    else:
        print "  + No interesting stack variables have been found!"

        
    # Print a list of dangerous functions
    interesting_calls = get_interesting_function_calls(func_addr)
    if len(interesting_calls) > 0:
        print "  + %d calls to known dangerous functions." % len(interesting_calls)
        for call_addr, call_func in interesting_calls.iteritems():
            print "    - %s call at 0x%08x" % (call_func, call_addr)
    else:
        print "  + No calls to known dangerous functions have been found!"




################################################################################
#
# locate_dangerous_functions function
#
################################################################################
def locate_dangerous_functions(prefix):
    
    nrefs = 0
    
    print "Scanning %s for code references to %d dangerous functions..." % (GetInputFile(), len(dangerous_functions)),
    for func in dangerous_functions.keys():
        prefixed_func = prefix + func  # Add the prefix to the function name
        addr = LocByName(prefixed_func)
    
        if addr != BADADDR:
            code_refs = CodeRefsTo(addr,0)

            print "\n"
            print "+ %s" % dangerous_functions[func]
            print "+ code references to %s (%08x):" % (prefixed_func, addr),
            for ref in code_refs:
                print "%08x" % ref,
                SetColor(ref,CIC_ITEM,0x0000ff)
                nrefs = nrefs + 1

    print "\n\n", nrefs, "references to a dangerous function found."    

    return




################################################################################
#
# Main function
#
################################################################################

print "\n\n"
print "--------------------------------------------------------------"
print "Hex-Rays IDA Pro Vulnerability Scanner plugin for PS3 v0.0.2"
print "Updated For PS3: esc0rtd3w <ps3xploit.me>"
print "\nOriginal: Gianni Gnesa (gnix) <research@ptrace-security.com>"
print "--------------------------------------------------------------\n"

file_type = AskStr("", "File type: \n(1) VSH _Export_stdc_; \n(2) SPRX _stdc_; \n(3) SELF _sysPrxForUser__sys_; \n(4) NO PREFIX;\n\nInsert no.:")

if file_type == "1":
    prefix = "_Export_stdc_"
elif file_type == "2":
    prefix = "_stdc_"
elif file_type == "3":
    prefix = "_sysPrxForUser__sys_"
elif file_type == "4":
    prefix = ""
else:
    print "File type not found!"
    exit()

option = AskStr("", "Mode: \n(1) Analyze function; \n(2) Locate dangerous functions; \n\nInsert no.:")
if option == "1":
    analyze_function()
elif option == "2":
    locate_dangerous_functions(prefix)
else:
    print "Mode number not found!"

print "\nDone!"



